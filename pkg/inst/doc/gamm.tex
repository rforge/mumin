\documentclass{article}
\usepackage[utf8]{inputenc}
\addtolength{\textwidth}{1.25in}
\addtolength{\oddsidemargin}{-.75in}
\setlength{\evensidemargin}{\oddsidemargin}

%\VignettePackage{MuMIn}
%\VignetteIndexEntry{Model selection with GAMM}
%\VignetteDepends{mgcv,gamm4}

\usepackage{url}
\newcommand{\code}[1]{{\tt #1}}
\newcommand{\pkg}[1]{{\tt #1}}
\newcommand{\sQuote}[1]{{`#1'}}
\newcommand{\dQuote}[1]{{``#1''}}

\title{Model selection using GAMM with \pkg{MuMIn} }
\date{\today}
\author{Kamil BartoÅ„}
\usepackage{Sweave}
\begin{document}
\maketitle


\section{Extending \pkg{MuMIn}'s functionality to support \code{gamm} }

The two principal functions in \pkg{MuMIn}, \code{model.avg} and \code{dredge}
rely on availability of methods for a several generic function for the class of
the given fitted model object.
These generic functions include ones defined in package \code{stats}
(\code{logLik}, \code{formula}, \code{nobs},
and optionally \code{deviance} which may simply return \code{NULL}), as well
as ones defined in \pkg{MuMIn} itself (\code{coeffs},
\code{getAllTerms} and \code{tTable}). In some cases the default methods may
work as well.

In case of \code{gamm} and \code{gamm4}, the returned object has no special
class, it is a list with two items: \code{lme} or \code{mer}, and \code{gam}
(with some information stripped from it).
Therefore no specific methods can be applied.

The solution is to provide a wrapper function for \code{gamm} that evaluates
the model and adds a class attribute onto it, e.g.:
\begin{Schunk}
\begin{Sinput}
> gamm <- function(...) structure(c(mgcv::gamm(...), list(call = match.call())), 
+     class = c("gamm", "list"))
\end{Sinput}
\end{Schunk}
similarly for \code{gamm4} (but assign the same class \code{gamm}):
\begin{Schunk}
\begin{Sinput}
> gamm4 <- function(...) structure(c(gamm4::gamm4(...), list(call = match.call())), 
+     class = c("gamm", "list"))
\end{Sinput}
\end{Schunk}

As the wrappers have the same names as the actual functions, use of them is
invisible for the user, and they mask the original functions on the level of
\code{.GlobalEnv}.

In addition, these wrappers add a \code{call} element, containing the original
call to the wrapper function. It is not necessary, but makes things easier later
on for \code{dredge}.

Once we have an object of class \code{gamm}, it is possible to provide methods
for it. First let us define the generic methods from \pkg{stats}.

\begin{Schunk}
\begin{Sinput}
> logLik.gamm <- function(object, ...) logLik(object[[if (is.null(object$lme)) "mer" else "lme"]], 
+     ...)
> formula.gamm <- function(x, ...) formula(x$gam, ...)
> nobs.gamm <- function(object, ...) nobs(object$gam, ...)
\end{Sinput}
\end{Schunk}

It should be noted here that the issue of what the log-likelihood for GAMM
should be is not entirely clear. The documentation for \code{gamm} states that
the log-likelihood of \code{lme} is not the one of the fitted GAMM. However,
comparing alternative models presents some evidence that it may be still
appropriate for \code{gamm}. Namely both the log-likelihood of fitted
\code{lme}, and one of the \code{lme} part of \code{gamm} (including only linear
terms to make the comparison adequate) have identical values.

\begin{Schunk}
\begin{Sinput}
> dat <- gamSim(6, n = 100, scale = 0.2, dist = "gaussian")
\end{Sinput}
\begin{Soutput}
4 term additive + random effectGu & Wahba 4 term additive model
\end{Soutput}
\begin{Sinput}
> fm1 <- gamm(y ~ x0 + x1 + x2 + x3, data = dat, random = list(fac = ~1), 
+     method = "ML")
> fm2 <- lme(y ~ x0 + x1 + x2 + x3, data = dat, random = list(fac = ~1), 
+     method = "ML")
> logLik(fm1$lme)
\end{Sinput}
\begin{Soutput}
'log Lik.' -214.5197 (df=7)
\end{Soutput}
\begin{Sinput}
> logLik(fm2)
\end{Sinput}
\begin{Soutput}
'log Lik.' -214.5197 (df=7)
\end{Soutput}
\end{Schunk}

Likewise is in the generalised case of \code{gamm4} and \code{lmer}:
\begin{Schunk}
\begin{Sinput}
> dat <- gamSim(6, n = 100, scale = 0.2, dist = "poisson")
\end{Sinput}
\begin{Soutput}
4 term additive + random effectGu & Wahba 4 term additive model
\end{Soutput}
\begin{Sinput}
> fmg1 <- gamm4(y ~ x0 + x1 + x2 + x3, family = poisson, data = dat, 
+     random = ~(1 | fac))
> fmg2 <- lmer(y ~ x0 + x1 + x2 + x3 + (1 | fac), family = poisson, 
+     data = dat)
> logLik(fmg1$mer)
\end{Sinput}
\begin{Soutput}
'log Lik.' -460.5087 (df=6)
\end{Soutput}
\begin{Sinput}
> logLik(fmg2)
\end{Sinput}
\begin{Soutput}
'log Lik.' -460.5087 (df=6)
\end{Soutput}
\end{Schunk}

Similarly, comparison of \code{gamm4} with a smooth term, with fixed two degrees
of freedom gives log-likelihood which is very close to that of \code{lmer} that
includes a linear and quadratic term.
\begin{Schunk}
\begin{Sinput}
> fmgs1 <- gamm4(y ~ x0 + s(x1, k = 3, fx = TRUE) + x2 + x3, family = poisson, 
+     data = dat, random = ~(1 | fac))
> fmgs2 <- lmer(y ~ x0 + x1 + I(x1^2) + x2 + x3 + (1 | fac), family = poisson, 
+     data = dat)
> logLik(fmgs1$mer)
\end{Sinput}
\begin{Soutput}
'log Lik.' -459.4854 (df=7)
\end{Soutput}
\begin{Sinput}
> logLik(fmgs2)
\end{Sinput}
\begin{Soutput}
'log Lik.' -460.3622 (df=7)
\end{Soutput}
\end{Schunk}

Normally, the object returned by \code{gam} inherits also from glm, so the
\code{nobs} method for \code{glm} is called, but in case of \code{gamm} the
\code{gam} element has only class \code{gam}, so we need to define method
directly (it just calls \code{nobs.glm}):

\begin{Schunk}
\begin{Sinput}
> nobs.gam <- function(object, ...) stats:::nobs.glm(object, ...)
\end{Sinput}
\end{Schunk}

Methods for generic functions defined in \pkg{MuMIn}:
\begin{Schunk}
\begin{Sinput}
> coeffs.gamm <- function(model) coef(model$gam)
> getAllTerms.gamm <- function(x, ...) getAllTerms(x$gam)
> tTable.gamm <- function(model, ...) tTable(model$gam)
\end{Sinput}
\end{Schunk}
(the name \code{tTable} is somewhat misleading, as the \code{data.frame}
returned does not need to contain \emph{t}-values, two columns are obligatory:
\sQuote{Estimate} and \sQuote{Std. Error})

\section{Model selection}


Now we have all the prerequisites to proceed with the model selection:


\begin{Schunk}
\begin{Sinput}
> set.seed(0)
> dat <- gamSim(6, n = 100, scale = 0.5, dist = "normal")
\end{Sinput}
\begin{Soutput}
4 term additive + random effectGu & Wahba 4 term additive model
\end{Soutput}
\begin{Sinput}
> fmgs2 <- gamm(y ~ s(x0) + s(x3) + f0, family = gaussian, data = dat, 
+     random = list(fac = ~1))
\end{Sinput}
\end{Schunk}
This model fits quite poor. This is deliberate, to justify the model averaging.

\begin{Schunk}
\begin{Sinput}
> head(dd2 <- dredge(fmgs2))
\end{Sinput}
\begin{Soutput}
Global model: gamm(y ~ s(x0) + s(x3) + f0, family = gaussian, data = dat, random = list(fac = ~1))
---
Model selection table 
  s(x0) s(x3) k AICc  delta weight
1             3 558.1 0.000 0.790 
3       +     5 562.1 4.002 0.107 
2 +           5 562.4 4.311 0.092 
4 +     +     7 566.5 8.439 0.012 
\end{Soutput}
\end{Schunk}
(Note that we get quite different results using \code{gamm4})

\begin{Schunk}
\begin{Sinput}
> summary(model.avg(dd2, subset = cumsum(weight) <= 0.95))